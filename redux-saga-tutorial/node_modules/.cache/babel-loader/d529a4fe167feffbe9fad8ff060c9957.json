{"ast":null,"code":"//align saga structure similar to redux actions: if you have a users file in your actions, you should have one in your sagas. it will take care of all the sagas relating to users actions.\n//creating first saga to get users list:\nimport { takeEvery, takeLatest, take, call, fork, put } from 'redux-saga/effects';\nimport * as actions from '../actions/users';\nimport * as api from '../api/users'; //function* is a generator function\n\nfunction* getUsers() {\n  try {\n    // once this call resolves, it will assign to result\n    const result = yield call(api.getUsers); // nothing below will happen until call finishes\n    // to send a redux success action, need to use sagas 'put'\n\n    yield put(actions.getUsersSuccess({\n      items: result.data.data\n    }));\n  } catch (e) {}\n}\n\nfunction* watchGetUsersRequest() {\n  yield takeEvery(actions.Types.GET_USERS_REQUEST, getUsers);\n}\n\nfunction* createUser(action) {\n  try {\n    //second argument is what you're passing in\n    yield call(api.createUser, {\n      firstName: action.payload.firstName,\n      lastName: action.payload.lastName\n    });\n    yield call(getUsers);\n  } catch (e) {\n    yield put(actions.usersError({\n      error: \"An error occured when trying to create the user\"\n    }));\n  }\n}\n\nfunction* watchCreateUserRequest() {\n  yield takeLatest(actions.Types.CREATE_USER_REQUEST, createUser);\n} // we're wrapping worker sagas in try catch blocks to prevent the error from bubbling up to the root saga, which could then potentially affect other sagas\n\n\nfunction* deleteUser({\n  userId\n}) {\n  try {\n    yield call(api.deleteUser, userId); //i.e. if this api call doesn't work, needs to be handled in the catch block!\n    // gets latest users to render:\n\n    yield call(getUsers);\n  } catch (e) {\n    //dispatch redux action to update users state with an error string\n    yield put(actions.usersError({\n      error: \"An error occured when trying to delete the user\"\n    }));\n  }\n}\n\nfunction* watchDeleteUserRequest() {\n  // the while loop: need to wait for this entire deleteUser saga to resolve, until we're able to come back to watching for DELETE_USER_REQUEST\n  while (true) {\n    // take simply returns the action that was dispatched\n    const action = yield take(actions.Types.DELETE_USER_REQUEST); // call deleteUser function with the argument of {userId: someid}\n\n    yield call(deleteUser, {\n      userId: action.payload.userId\n    });\n  }\n}\n\nconst usersSagas = [fork(watchGetUsersRequest), fork(watchCreateUserRequest), fork(watchDeleteUserRequest)];\nexport default usersSagas;","map":{"version":3,"sources":["/Users/mark/Desktop/code/redux-saga/redux-saga-tut/src/sagas/users.js"],"names":["takeEvery","takeLatest","take","call","fork","put","actions","api","getUsers","result","getUsersSuccess","items","data","e","watchGetUsersRequest","Types","GET_USERS_REQUEST","createUser","action","firstName","payload","lastName","usersError","error","watchCreateUserRequest","CREATE_USER_REQUEST","deleteUser","userId","watchDeleteUserRequest","DELETE_USER_REQUEST","usersSagas"],"mappings":"AAAA;AAEA;AACA,SAAQA,SAAR,EAAmBC,UAAnB,EAA+BC,IAA/B,EAAqCC,IAArC,EAA2CC,IAA3C,EAAiDC,GAAjD,QAA2D,oBAA3D;AACA,OAAO,KAAKC,OAAZ,MAAyB,kBAAzB;AACA,OAAO,KAAKC,GAAZ,MAAqB,cAArB,C,CAEA;;AACA,UAAUC,QAAV,GAAqB;AACnB,MAAG;AACD;AACA,UAAMC,MAAM,GAAG,MAAMN,IAAI,CAACI,GAAG,CAACC,QAAL,CAAzB,CAFC,CAGD;AACA;;AACA,UAAMH,GAAG,CAACC,OAAO,CAACI,eAAR,CAAwB;AAChCC,MAAAA,KAAK,EAAEF,MAAM,CAACG,IAAP,CAAYA;AADa,KAAxB,CAAD,CAAT;AAGD,GARD,CAQC,OAAMC,CAAN,EAAQ,CAER;AACF;;AAED,UAAUC,oBAAV,GAAiC;AAC/B,QAAMd,SAAS,CAACM,OAAO,CAACS,KAAR,CAAcC,iBAAf,EAAkCR,QAAlC,CAAf;AACD;;AAED,UAAUS,UAAV,CAAqBC,MAArB,EAA6B;AAC3B,MAAG;AACD;AACA,UAAMf,IAAI,CAACI,GAAG,CAACU,UAAL,EAAiB;AAACE,MAAAA,SAAS,EAAED,MAAM,CAACE,OAAP,CAAeD,SAA3B;AAAsCE,MAAAA,QAAQ,EAAEH,MAAM,CAACE,OAAP,CAAeC;AAA/D,KAAjB,CAAV;AACA,UAAMlB,IAAI,CAACK,QAAD,CAAV;AACD,GAJD,CAIC,OAAMK,CAAN,EAAQ;AACP,UAAMR,GAAG,CAACC,OAAO,CAACgB,UAAR,CAAmB;AAC3BC,MAAAA,KAAK,EAAE;AADoB,KAAnB,CAAD,CAAT;AAGD;AACF;;AAED,UAAUC,sBAAV,GAAmC;AACjC,QAAMvB,UAAU,CAACK,OAAO,CAACS,KAAR,CAAcU,mBAAf,EAAoCR,UAApC,CAAhB;AACD,C,CAED;;;AACA,UAAUS,UAAV,CAAqB;AAACC,EAAAA;AAAD,CAArB,EAA+B;AAC7B,MAAG;AACD,UAAMxB,IAAI,CAACI,GAAG,CAACmB,UAAL,EAAiBC,MAAjB,CAAV,CADC,CACmC;AACpC;;AACA,UAAMxB,IAAI,CAACK,QAAD,CAAV;AACD,GAJD,CAIC,OAAMK,CAAN,EAAS;AACR;AACA,UAAMR,GAAG,CAACC,OAAO,CAACgB,UAAR,CAAmB;AAC3BC,MAAAA,KAAK,EAAE;AADoB,KAAnB,CAAD,CAAT;AAGD;AACF;;AAED,UAAUK,sBAAV,GAAmC;AACjC;AACA,SAAM,IAAN,EAAY;AACV;AACA,UAAMV,MAAM,GAAG,MAAMhB,IAAI,CAACI,OAAO,CAACS,KAAR,CAAcc,mBAAf,CAAzB,CAFU,CAGV;;AACA,UAAM1B,IAAI,CAACuB,UAAD,EAAa;AACrBC,MAAAA,MAAM,EAAET,MAAM,CAACE,OAAP,CAAeO;AADF,KAAb,CAAV;AAGD;AACF;;AAED,MAAMG,UAAU,GAAG,CACjB1B,IAAI,CAACU,oBAAD,CADa,EAEjBV,IAAI,CAACoB,sBAAD,CAFa,EAGjBpB,IAAI,CAACwB,sBAAD,CAHa,CAAnB;AAMA,eAAeE,UAAf","sourcesContent":["//align saga structure similar to redux actions: if you have a users file in your actions, you should have one in your sagas. it will take care of all the sagas relating to users actions.\n\n//creating first saga to get users list:\nimport {takeEvery, takeLatest, take, call, fork, put} from 'redux-saga/effects';\nimport * as actions from '../actions/users';\nimport * as api from '../api/users';\n\n//function* is a generator function\nfunction* getUsers() {\n  try{\n    // once this call resolves, it will assign to result\n    const result = yield call(api.getUsers);\n    // nothing below will happen until call finishes\n    // to send a redux success action, need to use sagas 'put'\n    yield put(actions.getUsersSuccess({\n      items: result.data.data\n    }));\n  }catch(e){\n\n  }\n}\n\nfunction* watchGetUsersRequest() {\n  yield takeEvery(actions.Types.GET_USERS_REQUEST, getUsers);\n}\n\nfunction* createUser(action) {\n  try{\n    //second argument is what you're passing in\n    yield call(api.createUser, {firstName: action.payload.firstName, lastName: action.payload.lastName });\n    yield call(getUsers);\n  }catch(e){\n    yield put(actions.usersError({\n      error: \"An error occured when trying to create the user\"\n    }));\n  }\n}\n\nfunction* watchCreateUserRequest() {\n  yield takeLatest(actions.Types.CREATE_USER_REQUEST, createUser);\n}\n\n// we're wrapping worker sagas in try catch blocks to prevent the error from bubbling up to the root saga, which could then potentially affect other sagas\nfunction* deleteUser({userId}) {\n  try{\n    yield call(api.deleteUser, userId); //i.e. if this api call doesn't work, needs to be handled in the catch block!\n    // gets latest users to render:\n    yield call(getUsers);\n  }catch(e) {\n    //dispatch redux action to update users state with an error string\n    yield put(actions.usersError({\n      error: \"An error occured when trying to delete the user\"\n    }));\n  }\n}\n\nfunction* watchDeleteUserRequest() {\n  // the while loop: need to wait for this entire deleteUser saga to resolve, until we're able to come back to watching for DELETE_USER_REQUEST\n  while(true) {\n    // take simply returns the action that was dispatched\n    const action = yield take(actions.Types.DELETE_USER_REQUEST);\n    // call deleteUser function with the argument of {userId: someid}\n    yield call(deleteUser, {\n      userId: action.payload.userId\n    });\n  }\n}\n\nconst usersSagas = [\n  fork(watchGetUsersRequest),\n  fork(watchCreateUserRequest),\n  fork(watchDeleteUserRequest)\n];\n\nexport default usersSagas;"]},"metadata":{},"sourceType":"module"}